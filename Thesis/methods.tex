% Created 2020-06-05 Fri 12:35
% Intended LaTeX compiler: pdflatex
\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{grffile}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\author{Njagi Mwaniki}
\date{\today}
\title{}
\hypersetup{
 pdfauthor={Njagi Mwaniki},
 pdftitle={},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 26.3 (Org mode 9.2.4)}, 
 pdflang={English}}
\begin{document}

\tableofcontents

\section{Simulated Reads—SARS-CoV-2}
\label{sec:orgf056e3e}
\subsection{Fetch the reference}
\label{sec:org897351d}
Fetch latest, as of Jan 17 2020, COVID-19 reference.

\begin{verbatim}
efetch -db=nuccore -format=fasta -id=NC_045512.2 > ~/projects/Masters/verify/data/refs/COVID_19.fa
\end{verbatim}

\subsection{Simulate reads}
\label{sec:org122c97f}
Simulate 3 sets of reads. 2 that aren’t distantly related to the reference and 1 that is.
To do this we shall vary the mutation rate -r, default 0.0010, but keep the mutation frequency -F at a default, 0.5000. We want 1000 read pairs
Suggestions concerning the relationship between mutant frequency and mutation rate at the hprt locus in human peripheral T-lymphocytes
For 2 of them we shall use the same mutation rate but for one increase it.
Set ref as a var


\begin{verbatim}
export REF=~/projects/Masters/verify/data/refs/COVID_19.fa
\end{verbatim}

Simulate the reads
\begin{verbatim}
dwgsim -N 1000 $REF covid_19_sim_1
dwgsim -N 1000 $REF covid_19_sim_2
\end{verbatim}

Increase the mutation rate from the default 0.0010 to 0.0100

\begin{verbatim}
dwgsim -N 1000 -r 0.0100 $REF covid_19_sim_3
\end{verbatim}

\subsection{Construct the assembly graph}
\label{sec:org776bad2}
Assemble a coloured de Bruijn graph using Bifrost
What’s a colored graph? The colored de Bruijn graph is a variant of the de Bruijn graph which keeps track of the source of each vertex in the graph (Iqbal et al., 2012)
Prepare a sequences.txt file

\begin{verbatim}
~/projects/Masters/verify/data/reads/simulated/COVID_19/1/covid_19_sim_1_interleaved.fastq
~/projects/Masters/verify/data/reads/simulated/COVID_19/2/covid_19_sim_2_interleaved.fastq
~/projects/Masters/verify/data/reads/simulated/COVID_19/3/covid_19_sim_3_interleaved.fastq
\end{verbatim}

Build the graph using bifrost

\begin{verbatim}
Bifrost build \
  -c \
  -k 31 \
  -s sequences.txt \
  -o SARS-CoV-2
\end{verbatim}

When we view the DBG in bandage it looks like so:

Figure x:
\subsection{Bluntify/correct overlaps with gimbricate}
\label{sec:org3faadf1}
“bluntify” the GFA graph produced by a DBG assembler using gimbricate and seqwish, Bluntify means reducing overlaps on edges into nodes and edges in the graph itself.
We want to come from the DBG to a VG

\begin{verbatim}
gimbricate -d  \
  -g SARS-CoV-2.gfa \
  -p SARS-CoV-2.paf \
  -f SARS-CoV-2.fasta \
  > SARS-CoV-2.gimbry.gfa
\end{verbatim}

\subsection{Induce a variation graph}
\label{sec:orgb7bca38}
Induce a variation graph using seqwish
seqwish $\backslash$
  -s SARS-CoV-2.fasta $\backslash$
  -p SARS-CoV-2.paf $\backslash$
  -g SARS-CoV-2.seqwish.gfa

\subsection{Prepare the graph for use with VG}
\label{sec:org03a4171}
The GCSA2 indexer requires nodes to be no longer than 1024 bp, therefore, we have to use odgi chop to “chop”/reduce the sizes of these nodes.
\subsubsection{Build}
\label{sec:orgac8e624}
First build the graph with odgi build. Pass the -s flag to both build and sort the graph

\begin{verbatim}
odgi build \
  -s \
  -g SARS-CoV-2.seqwish.gfa \
  -o SARS-CoV-2-odgi-graph.vg
\end{verbatim}

\subsubsection{Chop}
\label{sec:org08ccf34}
odgi chop $\backslash$
  -i SARS-CoV-2-odgi-graph.vg $\backslash$
  -c 1024 $\backslash$
  -o SARS-CoV-2-odgi-chopped.vg

\subsubsection{Sort}
\label{sec:org83a9d5d}
Topologically order the graph
odgi sort $\backslash$
 -i SARS-CoV-2-odgi-chopped.vg $\backslash$
 -o SARS-CoV-2-odgi-sorted.vg

\subsubsection{odgi view}
\label{sec:org4318f05}
Projection of graphs into gfa
odgi view $\backslash$
 -i SARS-CoV-2-odgi-sorted.vg $\backslash$
 -g $\backslash$
 > SARS-CoV-2-odgi.gfa


\subsection{Mapping}
\label{sec:org5bd7036}
Now that we have prepared the graph for vg using odgi it’s time to use vg
\subsubsection{vg view}
\label{sec:orge102104}
Usage: vg view [options] [ <graph.vg> | <graph.json> | <aln.gam> | <read1.fq> [<read2.fq>] ]
options:
    -g, --gfa                  output GFA format (default)
    -F, --gfa-in               input GFA format, reducing overlaps if they occur
    -v, --vg                   output VG format

vg view -Fv SARS-CoV-2-odgi.gfa > SARS-CoV-2-vg.vg
\subsubsection{vg index}
\label{sec:orgcc35843}
Index the graph to allow for mapping
Creates an index on the specified graph or graphs. All graphs indexed must
already be in a joint ID space.
xg options:
    -x, --xg-name FILE     use this file to store a succinct, queryable version of the graph(s), or read for GCSA indexing
gcsa options:
    -g, --gcsa-out FILE    output a GCSA2 index to the given file
    -k, --kmer-size N      index kmers of size N in the graph (default 16)

vg index -x SARS-CoV-2.xg -g SARS-CoV-2.gcsa SARS-CoV-2-vg.vg

Building the index is not so instantaneous.
\subsubsection{vg map}
\label{sec:org83e5fef}
Generate a \texttt{gam} file
Map our reads to the graph for each set of reads that we have from 1 to 3 So for this let’s write a bash script
for i in \{1..3\}
do 
 vg map $\backslash$
    -f \textasciitilde{}/projects/Masters/verify/data/reads/simulated/COVID\textsubscript{19}/\({i}/covid_19_sim_\)\{i\}\textsubscript{interleaved.fastq} $\backslash$
    -x SARS-CoV-2.xg $\backslash$
    -g SARS-CoV-2.gcsa $\backslash$
    > SARS-CoV-2-\$\{i\}.gam
done
\subsection{Calculate coverage across the graph for each biosample}
\label{sec:org16b514a}
Use vg pack to get a coverage vector for each biosample
-d, --as-table         write table on stdout representing packs

for i in \{1..3\}
do 
 vg pack $\backslash$
   -x SARS-CoV-2.xg $\backslash$
   -g SARS-CoV-2-\({i}.gam \
   -d \
   > SARS-CoV-2-\)\{i\}.pack.table
done

View the tables as a pandas dataframe


\section{Actual Reads—RSV}
\label{sec:orgf6cddaa}
\subsection{Preprocessing}
\label{sec:org9510b9f}
\subsubsection{Quality control}
\label{sec:org2820621}
cat all the files in \textasciitilde{}/miniconda3/share/trimmomatic-0.39-1/adapters/ into one file. In my case adapters.fa.
Remove reads beyond QC of 35 and trim the adapters
 trimmomatic PE $\backslash$
  data/H\textsubscript{528}\textsubscript{16}\textsubscript{04}/H\textsubscript{528}\textsubscript{16}\textsubscript{04}\textsubscript{1.fastq.gz} data/H\textsubscript{528}\textsubscript{16}\textsubscript{04}/H\textsubscript{528}\textsubscript{16}\textsubscript{04}\textsubscript{2.fastq.gz} $\backslash$
  trimmed\textsubscript{forward}\textsubscript{paired.fq.gz} trimmed\textsubscript{forward}\textsubscript{unpaired.fq.gz} trimmed\textsubscript{reverse}\textsubscript{paired.fq.gz} trimmed\textsubscript{reverse}\textsubscript{unpaired.fq.gz} $\backslash$
  ILLUMINACLIP:adapters/adapters.fa:2:35:10:2:keepBothReads $\backslash$
  SLIDINGWINDOW:4:35 $\backslash$

I then compiled the interleaved reads filepaths to a txt file:

find \$(pwd)/data -d -name '*interleave*fq' > sequences.txt

Two datasets were causing seqwish to crash so I removed them from sequences.txt
data/H\textsubscript{536}\textsubscript{09}\textsubscript{04}/H\textsubscript{536}\textsubscript{09}\textsubscript{04}\textsubscript{interleaved.fq}:1271846:AGAACTCAGTGTAGGTAGAATGGTTGGCTGATCAATATCTCTAATGATTTTGGTCTGTGAATCAACTGTCATAAGAGAATTCTATCAAAGTTGAATTCCGAATCCTTGGGTCAATGACTGGGTGCACCCATTCTTCTAATGTGCTCTGTC
data/H\textsubscript{506}\textsubscript{13}\textsubscript{04}/H\textsubscript{506}\textsubscript{13}\textsubscript{04}\textsubscript{interleaved.fq}:3831798:AGAACTCAGTGTAGGTAGAATGGTTGGCTGAGTAGGTAGATGGAGGCAGGTGCATGTGTGATGGGAAGTGTGGTGACGGGTTGTGTGGGCACACGGGATGAGGCGCAGATGGCTGGGGGTTTGGGAGGGGAATGGGTGGGAGAAGGAGGC

\subsection{Construct the assembly graph  using minia}
\label{sec:org193c5ab}
minia uses bcalm2 internally. The unitig graph that it produces is the bcalm2 construction. Minia is then applying a bunch of assembly heuristics to reduce the complexity of the graph and try to get out longer contigs. I find it's better to use than the raw DBG.

Given the nature of our dataset: 
51 samples
Each fastq is about 400-500M in size
In order to get a graph that we expect (similar strcutre and approximate size to the expected genome) we have to set a high minimum abundance.
Using a k-mer size of 31 and a minimum abundance of 2000 the assembly graph is 237K (about 20x the genome size).  When we use a min abundance of 1000 we get a GFA of 157K (10x the genome size) but we “lose one of the variable regions".
minia -in ../sequence\textsubscript{paths.txt} $\backslash$
  -kmer-size 31 $\backslash$
  -abundance-min 1000 $\backslash$
  -nb-cores 8

Figure x: a minimum abundance of 1000

Figure x: a minimum abundance of 2000
\subsection{Bluntify the graph using stark}
\label{sec:org4a58923}
Going with the 1000 min abundance graph. We chose to bluntify it using stark (\url{https://github.com/hnikaein/stark}) 
stark -i input\textsubscript{file}\textsubscript{name} $\backslash$
  -o stark\textsubscript{bluntify.gfa} $\backslash$
  -s cpu-consuming

Yields a  206K GFA that when visualized looks like so

Figure x: bluntified graph 


\subsection{Prepare the graph for mapping with vg}
\label{sec:org7ef6b84}
Odgi is\ldots{}
I combine a series of commands into this bash script
\#!/usr/bin/env bash

InputGFA=\$1
BuildVG="build-odgi.vg"
ChoppedVG="chopped-odgi.vg"
SortedVG="sorted-odgi.vg"
ViewGFA="view-odgi.gfa"

echo "Using \$InputGFA"

odgi build $\backslash$
     -s $\backslash$
     -g \$\{InputGFA\} $\backslash$
     -o \$\{BuildVG\}

echo "Chopping to size 1024"

odgi chop $\backslash$
     -i build-odgi.vg $\backslash$
     -c 1024 $\backslash$
     -o \$\{ChoppedVG\}

echo "Sorting"

odgi sort $\backslash$
     -i chopped-odgi.vg $\backslash$
     -o \$\{SortedVG\}

echo "Generating GFA \$ViewGFA"

odgi view $\backslash$
     -i sorted-odgi.vg $\backslash$
     -g $\backslash$
     > \$\{ViewGFA\}


Run with
./pre-map.sh stark\textsubscript{bluntify.gfa}
Visualize the graph to see


\subsection{Mapping with vg}
\label{sec:orgbed63d9}
\subsubsection{Convert GFA to vg compatible variation graph}
\label{sec:org0016f67}
Get a vg compatible variation graph out of the gfa
vg view -Fv view-odgi.gfa > graph.vg
3.2.5.2 Index
In this case I don’t want to prune because our graph (graph.vg)  is small (62k) and I don’t want to lose complex regions (e.g. regions with many variants close to each other)
\url{https://github.com/vgteam/vg/wiki/Index-Construction\#without-haplotypes}
\url{https://github.com/vgteam/vg/wiki/Index-Construction\#without-a-reference-or-haplotypes}
I don’t want to prune and will therefore build the index like so
vg index -x graph.xg -g graph.gcsa graph.vg

We get a 61K graph.xg and a 258K graph.gcsa.
\subsubsection{Mapping}
\label{sec:org8ec65dc}
We want to map each sample against the graph. For this we use we want to loop through each of our interleaves sequences and put the outpur gam files in a directory we specify. We use the bash script below.

\#!/usr/bin/env bash

Graphname="graph"

GAMDir="gams"

while read Filepath;
do

Filename=\({Filepath##*/}
    FileStub=\)\{Filename\%\textsubscript{*}\}

echo "Mapping \$FileStub"
vg map $\backslash$
   -f \$\{Filepath\} $\backslash$
   -x \$\{Graphname\}.xg $\backslash$
   -g \$\{Graphname\}.gcsa $\backslash$
   > \({GAMDir}/\)\{FileStub\}.gam

Run with
./map.sh < ../sequence\textsubscript{paths.txt}

Verify a GAM converting the converting to GAMP and viewing in JSON the
\url{https://github.com/vgteam/vg/wiki/Visualization\#viewing-alignments}
\url{https://github.com/vgteam/vg/wiki/Multipath-alignments-and-vg-mpmap}

vg view -a -k gams/H\textsubscript{513}\textsubscript{02}\textsubscript{04.gam} > Images/H\textsubscript{513}\textsubscript{02}\textsubscript{04.gamp}

vg view -K -j Images/H\textsubscript{513}\textsubscript{02}\textsubscript{04.gamp} > Images/H\textsubscript{513}\textsubscript{02}\textsubscript{04}\textsubscript{GAMP.json}

cat Images/H\textsubscript{513}\textsubscript{02}\textsubscript{04}\textsubscript{GAMP.json} | jq | less

\subsection{Calculate coverage across the graph for each biosample}
\label{sec:org95048e7}
We want all our coverage vectors in a coverage dir.
mkdir coverage/

Use this this coverage.bash to generate a coverage vector as a table
\#!/usr/bin/env bash

Graphname="graph"
CoverageDir="coverage"

while read Filepath;
do

FileStub=\$\{Filepath\%.*\}

    vg pack $\backslash$
       -d $\backslash$
       -x \$\{Graphname\}.xg $\backslash$
       -g \$\{Filepath\} $\backslash$
       > \({CoverageDir}/\)\{FileStub\}.pack.table
done
Run with
find \$(pwd)/gams -d -name '*.gam' > gams.txt
./map.sh < gams.txt

./coverage.sh < find \$(pwd)/gams -d -name '*.gam'
\end{document}
